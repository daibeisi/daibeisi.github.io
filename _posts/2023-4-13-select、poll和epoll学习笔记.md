---
layout:     post
title:      IO 多路复用 – SELECT VS POLL VS EPOLL
date:       2023-4-13
author:     呆贝斯
header-img: img/post-bg-rwd.jpg
catalog: true
tags:
    - select
    - poll
    - epoll
---
# select
select最早于1983年出现在4.2BSD中，它`通过一个select()系统调用来监视多个文件描述符的数组`，当select()返回后，
该数组中就绪的文件描述符便会被内核修改标志位，使得进程可以获得这些文件描述符从而进行后续的读写操作。

`select目前几乎是所有平台支持`，其良好跨平台支持也是它的一个优点，事实上从现在看来，这也是它所剩不多的优点之一。

`select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制`，在Linux上一般为1024，
不过可以通过修改宏定义甚至重新编译内核的方式提升这一限制。另外，select所维护的存储大量文件描述符的数据结构，随着文件描述符数量的增大，
其复制的开销也线性增长。同时，由于网络响应时间的延迟使得大量TCP连接处于非活跃状态，但调用`select会对所有socket进行一次线性扫描`，
所以这也浪费了一定的开销。

# poll
poll在1986年诞生于System V Release 3，它`和select在本质上没有多大区别，但是poll没有最大文件描述符数量的限制`。

poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核态的地址空间之间，而不论这些文件描述符是否就绪，
他的开销随着文件描述符的增加而线性增加。另外，select和poll将就绪的文件描述符告诉进程后，如果进程没有对其进行IO操作，
那么下次掉用select和poll的时候将再次报告这些文件描述符，所以它们一般不会丢失就绪的消息，这种方式称为水平触发。

# epoll

直到Linux2.6才出现了由内核直接支持的实现方法，那就是epoll，被公认为Linux2.6下性能最好的多路I/O就绪通知方法。

epoll可以同时支持水平触发和边缘触发（只告诉进程哪些文件描述符刚刚变为就绪状态，它只告诉一遍，如果没有采取行动，那么他将不会再次告知，
这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但代码实现相当复杂。

epoll同样只告知那些就绪的文件描述符，而且当我们强调epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，
而是一个代表就绪描述符数量的值，你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射技术，
这样便彻底省掉了这些文件描述符在系统调用时复制的开销。另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select或poll中，
进程只有调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，
一旦基于某个描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。
