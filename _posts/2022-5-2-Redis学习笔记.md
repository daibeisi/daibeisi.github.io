---
layout:     post
title:      Redis学习笔记
subtitle:   ......
date:       2022-5-2
author:     呆贝斯
header-img: img/post-bg-desk.jpg
catalog: true
tags:
    - Redis
    - Python
---
## Redis数据库介绍
Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。
它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。
内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，
通过Redis Cluster提供自动分区。官方给出的数据显示能够达到10w/s的QPS处理，但是在生产环境的实测结果大概读取QPS在7-9w/s，
写入QPS在6-8w/s左右（注：与机器性能也有关）。

## 安装及配置
官网：https://redis.io/

## Redis基本数据类型与常用指令
### 常用命令
| 命令                       | 作用                                     |
|--------------------------|----------------------------------------|
| keys *                   | 返回所有键（keys还能用来搜索，比如keys h*：搜索所有以h开头的键） |
| dbsize                   | 返回键数量，如果存在大量键，线上禁止使用此指令                |
| exists key               | 检查键是否存在，存在返回 1，不存在返回 0                 |
| del key                  | 删除键，返回删除键个数，删除不存在键返回 0                 |
| ttl key                  | 查看键存活时间，返回键剩余过期时间，不存在返回-1              |
| expire key seconds       | 设置过期时间（单位：s），成功返回1，失败返回0               |
| expireat key timestamp   | 设置key在某个时间戳（精确到秒）之后过期                  |
| pexpire key milliseconds | 设置过期时间（单位：ms），成功返回1，失败返回0              |
| persist key              | 去掉过期时间                                 |
| monitor                  | 实时监听并返回Redis服务器接收到的所有请求信息              |
| shutdown                 | 把数据同步保存到磁盘上，并关闭Redis服务                 |
| info                     | 查看当前Redis节点信息                          |

### 基本数据类型
| 类型          | 描述                                                          | 特性                                       | 场景                                            |
|-------------|-------------------------------------------------------------|------------------------------------------|-----------------------------------------------|
| string      | 二进制安全                                                       | 可以存储任何元素（数字、字符、音视频、图片、对象.....）           | 计数器、分布式锁、字符缓存、分布式ID生成、session共享、秒杀token、IP限流等 |
| hash        | 键值对存储，类似于Map集合                                              | 适合存储对象，可以将对象属性一个个存储，更新时也可以更新单个属性，操作某一个字段 | 对象缓存、购物车等                                     |
| list        | 双向链表                                                        | 增删快                                      | 栈、队列、有限集合、消息队列、消息推送、阻塞队列等                     |
| set         | 元素不能重复，每次获取无序                                               | 添加、删除、查找的复杂度都是O(1)，提供了求交集、并集、差集的操作       | 抽奖活动、朋友圈点赞、用户（微博好友）关注、相关关注、共同关注、好友推荐（可能认识的人）等 |
| sorted set  | 有序集合，每个元素有一个对应的分数，不允许元素重复                                   | 基于分数进行排序，如果分数相等，以key值的 ascii 值进行排序       | 商品评价标签（好评、中评、差评等）、排行榜等                        |
| bitmaps     | Bitmaps是一个字节由 8 个二进制位组成                                     | 在字符串类型上面定义的位操作                           | 在线用户统计、用户访问统计、用户点击统计等                         |
| hyperloglog | Redis2.8.9版本添加了 HyperLogLog结构。Redis HyperLogLog是用来做基数统计的算法。 | 用于进行基数统计，不是集合，不保存数据，只记录数量而不是具体数据统计独立UV等  |
| geospatial  | Redis3.2版本新增的数据类型：GEO对地理位置的支持                               | 以将用户给定的地理位置信息储存起来， 并对这些信息进行操作            | 地理位置计算                                        |
| stream      | Redis5.0之后新增的数据类型                                           | 支持发布订阅，一对多消费                             | 消息队列                                          |

```
字符串相关操作
    set -- 设置值
    get -- 获取值
    mset -- 设置多个键值对
    mget -- 获取多个键值对
    append -- 添加字符串
    del -- 删除
    incr/decr -- 增加/减少1
列表相关操作
    lpush/rpush  -- 从左/右添加数据
    lrange -- 获取指定长度信息
    ltrim -- 截取指定长度信息
    llen -- 获取长度
    lpop/rpop -- 移除最左或右数据
    lpushx/rpushx -- key存在才会加入数据，不存在不会做任何事情
集合相关操作
    sadd/srem -- 添加/删除元素
    sismember -- 判断是否为set的一个元素
    smembers -- 返回该集合的所有成员
    sdiff -- 返回一个集合和其他集合的差异
    sinter -- 返回几个集合的交集
    sunion -- 返回几个集合的并集
散列相关操作
    hset/hget -- 设置/获取散列值
    hmset/hmget -- 设置/获取多对散列值
    hsetx -- 如果散列已经存在，则不设置
    hkeys/hvals -- 返回所有Keys/Values
    hlen -- 返回散列包含域（field）的数量
    hdel -- 删除散列指定域（field）
    hexists -- 判断是否存在
```

## redis相关问题及解决办法
### 缓存一致性

### 缓存雪崩
问题描述：指在某一个时间段，缓存集中过期失效或Redis宕机。比如 ：双十一零点，抢购，这波商品应该放在缓存区，假设缓存一小时，
到了凌晨一点，商品缓存过期，而对于这批商品的访问，都跑到数据库中，对于数据库，产生压力峰。所有请求都会到达存储层，存储层的调用量增加，
存储层狗带（缓存服务节点的宕机，对数据库服务器造成的压力不可预知）。

解决方案：
1. redis高可用（多增加redis）。
2. 数据预热（在正式部署之前，把可能的数据先访问一遍）。
3. 设置随机失效keys，错开过期时间。
4. 使用分布式锁或者MQ队列使得请求串行化，从而避免同一时间请求大量落入DB（性能会受到很大的影响）。

### 缓存穿透
问题描述：用户想要查询一个数据，发现Redis内存数据库里没有，也就是缓存没有命中，于是向持久层的数据库查询，发现也没有，
于是本次查询失败，当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库，这会给持久层数据库造成很大的压力，出现缓存穿透。

解决方案：布隆过滤器

布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的压力。
但是如果空值能被缓存起来，这就意味着缓存需要更多的空间存储更多的键，即使对空值设置了过期时间，
还是会存在缓存层和存储层的数据会有一段时间的窗口不一致

优点：使用二进制组成的数组，内存占用率小，且插入和查询速度够快

缺点：随着数据增加，二进制数组中值的覆盖率增加，只能判断数据不存在，不能明确判定数据存在，且无法删除数据

### 缓存击穿
问题描述：是指某一个key 非常热点，在不停的扛着大的并发，大并发集中对这个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，
直接请求数据库。当某个key过期的瞬间，就会有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，
并且回写缓存，会导致数据库瞬间压力过大。

解决方案：
1. 设置热点数据永不过期。 
2. 加互斥锁：使用分布式锁，保证每一个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，只需等待（对分布锁要求高）

## 淘汰策略
maxmemory-policy：参数配置淘汰策略。maxmemory：限制内存大小。
| 策略               | 概述                                                                                         |
|------------------|--------------------------------------------------------------------------------------------|
| volatile-lru     | 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰，没有设置过期时间的key不会被淘汰，这样就可以在增加内存空间的同时保证需要持久化的数据不会丢失。                |
| volatile-ttl     | 从已设置过期时间的数据集中挑选将要过期的数据淘汰，ttl值越大越优先被淘汰。                                                     |
| volatile-random  | 从已设置过期时间的数据集中任意选择数据淘汰                                                                      |
| volatile-lfu     | 从已设置过期时间的数据集挑选使用频率最低的数据淘汰                                                                  |
| allkeys-lru      | 从数据集中挑选最近最少使用的数据淘汰，该策略要淘汰的key面向的是全体key集合，而非过期的key集合（应用最广泛的策略）。                             |
| allkeys-lfu      | 从数据集中挑选使用频率最低的数据淘汰                                                                         |
| allkeys-random   | 从数据集（server.db[i].dict）中任意选择数据淘汰                                                           |
| no-enviction（驱逐） | 禁止驱逐数据，这也是默认策略。意思是当内存不足以容纳新入数据时，新写入操作就会报错，请求可以继续进行，线上任务也不能持续进行，采用no-enviction策略可以保证数据不被丢失。 |
1. 在Redis中，数据有一部分访问频率较高，其余部分访问频率较低，或者无法预测数据的使用频率时，设置allkeys-lru是比较合适的。
2. 如果所有数据访问概率大致相等时，可以选择allkeys-random。
3. 如果研发者需要通过设置不同的ttl来判断数据过期的先后顺序，此时可以选择volatile-ttl策略。
4. 如果希望一些数据能长期被保存，而一些数据可以被淘汰掉时，选择volatile-lru或volatile-random都是比较不错的。
5. 由于设置expire会消耗额外的内存，如果计划避免Redis内存在此项上的浪费，可以选用allkeys-lru策略，这样就可以不再设置过期时间，高效利用内存了。

## 键删除策略
Redis默认采用定期+惰性删除策略。
### 定时删除
在设置键的过期时间的同时，设置一个定时器，当键过期了，定时器马上把该键删除。
（定时删除对内存来说是友好的，因为它可以及时清理过期键；但对CPU是不友好的，如果过期键太多，删除操作会消耗过多的资源。）
### 惰性删除
key过期后任然留在内存中不做处理，当有请求操作这个key的时候，会检查这个key是否过期，如果过期则删除，否则返回key对应的数据信息。
（惰性删除对CPU是友好的，因为只有在读取的时候检测到过期了才会将其删除。但对内存是不友好，如果过期键后续不被访问，那么这些过期键将积累在缓存中，对内存消耗是比较大的。）
### 定期删除
Redis数据库默认每隔100ms就会进行随机抽取一些设置过期时间的key进行检测，过期则删除。
（定期删除是定时删除和惰性删除的一个折中方案。可以根据实际场景自定义这个间隔时间，在CPU资源和内存资源上作出权衡。）

## 持久化机制
### RDB持久化

### AOF持久化

### 混合型持久化

## 事务机制
Redis作为数据库当然是支持事务的，只不过Redis的事务机制是弱事务，相对来说比较鸡肋，官方给出如下几个指令来进行Redis的事务控制：
* MULTI：标记一个事务块的开始
* DISCARD：取消事务，放弃执行事务块内的所有命令
* EXEC：执行所有事务块内的命令
* UNWATCH：取消WATCH命令对所有key的监视
* WATCH key [key ...]：监视一个(或多个)key，如果在事务执行之前这个(或这些)key被其他命令所改动，那么事务将被打断

## 内存模型及内存划分

## 虚拟内存

## Redis客户端通信RESP协议
RESP是Redis序列化协议，Redis客户端RESP协议与Redis服务器通信。RESP协议在Redis 1.2中引入，
但在Redis 2.0中成为与Redis服务器通信的标准方式。这个通信方式就是Redis客户端实现的协议。
RESP实际上是一个序列化协议，它支持以下数据类型:简单字符串、错误、整数、大容量字符串和数组。
当我们在客户端中像Redis发送操作命令时，比如：set name 张三 这条命令，不会直接以这种格式的形式发送到Redis Server，
而是经过RESP的序列化之后再发送给Redis执行，而AOF持久化机制持久化之后生成的AOF文件中也并不是存储set name 张三 这个指令，
而是存储RESP序列化之后的指令，RESP的特点如下：
* 实现简单
* 能被计算机快速地解析
* 可读性好能够被人工解析

## 高可用机制
### 主从复制
### 哨兵
### 代理式集群
### 去中心化分布式集群

## 新版本特性