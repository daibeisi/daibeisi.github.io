---
layout:     post
title:      Python操作Redis
subtitle:   ......
date:       2022-4-28
author:     呆贝斯
header-img: img/post-bg-desk.jpg
catalog: true
tags:
    - Redis
    - Python
---
# Redis数据库基础
1. Redis数据库介绍
    + `用途`：数据库、缓存和消息中间件
    + `类型`：
        1. 字符串（strings）
        2. 散列（hashes）
        3. 列表（lists）
        4. 集合（sets）
        5. 有序集合（sorted sets）

2. 安装及配置

   `官网`：https://redis.io/

3. Redis常用操作
    + `字符串相关操作`
        + set -- 设置值
        + get -- 获取值
        + mset -- 设置多个键值对
        + mget -- 获取多个键值对
        + append -- 添加字符串
        + del -- 删除
        + incr/decr -- 增加/减少1
    + `列表相关操作`
        + lpush/rpush  -- 从左/右添加数据
        + lrange -- 获取指定长度信息
        + ltrim -- 截取指定长度信息
        + llen -- 获取长度
        + lpop/rpop -- 移除最左或右数据
        + lpushx/rpushx -- key存在才会加入数据，不存在不会做任何事情
    + `集合相关操作`
        + sadd/srem -- 添加/删除元素
        + sismember -- 判断是否为set的一个元素
        + smembers -- 返回该集合的所有成员
        + sdiff -- 返回一个集合和其他集合的差异
        + sinter -- 返回几个集合的交集
        + sunion -- 返回几个集合的并集
    + `散列相关操作`
        + hset/hget -- 设置/获取散列值
        + hmset/hmget -- 设置/获取多对散列值
        + hsetx -- 如果散列已经存在，则不设置
        + hkeys/hvals -- 返回所有Keys/Values
        + hlen -- 返回散列包含域（field）的数量
        + hdel -- 删除散列指定域（field）
        + hexists -- 判断是否存在

# redis相关问题及解决办法
+ `缓存穿透`

   问题描述：用户想要查询一个数据，发现Redis内存数据库里没有，也就是缓存没有命中，于是向 持久层的数据库查询，发现也没有，于是本次查询失败，当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库，这会给持久层数据库造成很大的压力，出现缓存穿透。

   解决方案：布隆过滤器
   
   布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的压力。
   但是如果空值能被缓存起来，这就意味着缓存需要更多的空间存储更多的键，即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间的窗口不一致

   优点：使用二进制组成的数组，内存占用率小，且插入和查询速度够快

   缺点：随着数据增加，二进制数组中值的覆盖率增加，只能判断数据不存在，不能明确判定数据存在，且无法删除数据
+ `缓存击穿`

   问题描述：是指某一个key 非常热点，在不停的扛着大的并发，大并发集中对这个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库。当某个key过期的瞬间，就会有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导致数据库瞬间压力过大。

   解决方案：1. 设置热点数据永不过期。 2. 加互斥锁：使用分布式锁，保证每一个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，只需等待（对分布锁要求高）

+ `缓存雪崩`

   问题描述：指在某一个时间段，缓存集中过期失效，Redis宕机。比如 ：双十一零点，抢购，这波商品应该放在缓存区，假设缓存一小时，到了凌晨一点，商品缓存过期，而对于这批商品的访问，都跑到数据库中，对于数据库，产生压力峰。所有请求都会到达存储层，存储层的调用量增加，存储层狗带（缓存服务节点的宕机，对数据库服务器造成的压力不可预知）。
   
   解决方案：1. redis高可用（多增加redis）。 2. 限流降级（通过加锁来控制数据库写缓存的线程数量）。 3. 数据预热（在正式部署之前，把可能的数据先访问一遍）。 4. 设置随机失效keys。
