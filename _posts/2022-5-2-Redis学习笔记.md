---
layout:     post
title:      Redis学习笔记
subtitle:   ......
date:       2022-5-2
author:     呆贝斯
header-img: img/post-bg-desk.jpg
catalog: true
tags:
    - Redis
    - Python
---
## Redis数据库介绍
Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。
它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。
内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，
通过Redis Cluster提供自动分区。官方给出的数据显示能够达到10w/s的QPS处理，但是在生产环境的实测结果大概读取QPS在7-9w/s，
写入QPS在6-8w/s左右（注：与机器性能也有关）。

## 安装及配置
官网：https://redis.io/

## Redis常用操作
```
字符串相关操作
    set -- 设置值
    get -- 获取值
    mset -- 设置多个键值对
    mget -- 获取多个键值对
    append -- 添加字符串
    del -- 删除
    incr/decr -- 增加/减少1
列表相关操作
    lpush/rpush  -- 从左/右添加数据
    lrange -- 获取指定长度信息
    ltrim -- 截取指定长度信息
    llen -- 获取长度
    lpop/rpop -- 移除最左或右数据
    lpushx/rpushx -- key存在才会加入数据，不存在不会做任何事情
集合相关操作
    sadd/srem -- 添加/删除元素
    sismember -- 判断是否为set的一个元素
    smembers -- 返回该集合的所有成员
    sdiff -- 返回一个集合和其他集合的差异
    sinter -- 返回几个集合的交集
    sunion -- 返回几个集合的并集
散列相关操作
    hset/hget -- 设置/获取散列值
    hmset/hmget -- 设置/获取多对散列值
    hsetx -- 如果散列已经存在，则不设置
    hkeys/hvals -- 返回所有Keys/Values
    hlen -- 返回散列包含域（field）的数量
    hdel -- 删除散列指定域（field）
    hexists -- 判断是否存在
```

## redis相关问题及解决办法

### 缓存雪崩
问题描述：指在某一个时间段，缓存集中过期失效或Redis宕机。比如 ：双十一零点，抢购，这波商品应该放在缓存区，假设缓存一小时，
到了凌晨一点，商品缓存过期，而对于这批商品的访问，都跑到数据库中，对于数据库，产生压力峰。所有请求都会到达存储层，存储层的调用量增加，
存储层狗带（缓存服务节点的宕机，对数据库服务器造成的压力不可预知）。

解决方案：
1. redis高可用（多增加redis）。
2. 使用分布式锁或者MQ队列使得请求串行化，从而避免同一时间请求大量落入DB（性能会受到很大的影响）。
3. 数据预热（在正式部署之前，把可能的数据先访问一遍）。
4. 设置随机失效keys，错开过期时间。

### 缓存穿透
问题描述：用户想要查询一个数据，发现Redis内存数据库里没有，也就是缓存没有命中，于是向持久层的数据库查询，发现也没有，
于是本次查询失败，当用户很多的时候，缓存都没有命中，于是都去请求了持久层数据库，这会给持久层数据库造成很大的压力，出现缓存穿透。

解决方案：布隆过滤器

布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的压力。
但是如果空值能被缓存起来，这就意味着缓存需要更多的空间存储更多的键，即使对空值设置了过期时间，
还是会存在缓存层和存储层的数据会有一段时间的窗口不一致

优点：使用二进制组成的数组，内存占用率小，且插入和查询速度够快

缺点：随着数据增加，二进制数组中值的覆盖率增加，只能判断数据不存在，不能明确判定数据存在，且无法删除数据

### 缓存击穿
问题描述：是指某一个key 非常热点，在不停的扛着大的并发，大并发集中对这个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，
直接请求数据库。当某个key过期的瞬间，就会有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，
并且回写缓存，会导致数据库瞬间压力过大。

解决方案：
1. 设置热点数据永不过期。 
2. 加互斥锁：使用分布式锁，保证每一个key同时只有一个线程去查询后端服务，其他线程没有获得分布式锁的权限，只需等待（对分布锁要求高）

## 键删除策略

### 定时删除
### 惰性删除
### 定期删除

## 持久化机制

### RDB持久化
### AOF持久化
### 混合型持久化

## 事务机制

## 内存模型及内存划分

## 虚拟内存

## Redis客户端通信RESP协议

## 高可用机制

### 主从复制
### 哨兵
### 代理式集群
### 去中心化分布式集群

## 新版本特性