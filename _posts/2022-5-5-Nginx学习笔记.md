---
layout:     post
title:      Nginx学习笔记
subtitle:   ......
date:       2022-5-5
author:     呆贝斯
header-img: img/tag-bg-o.jpg
onTop: true
catalog: true
tags:
    - Nginx
---
##  Nginx基本概念
Nginx（发音为“engine-x”）是用于 HTTP、HTTPS、SMTP、POP3 和 IMAP 协议的开源反向代理服务器，以及负载均衡器、
HTTP 缓存和 Web 服务器（源服务器）。nginx 项目一开始就非常关注高并发、高性能和低内存使用，性能是其最重要的考量，
实现上非常注重效率，能经受高负载的经验，有报告表明能支持高达50000个并发连接数。
![Nginx运行原理图](/img/nginx_principle.png)
![Worker工作原理](/img/nginx_worker.png)

`一个Master和多个Worker的好处？`

1. 可以使用nginx -s reload热部署，利于nginx进行热部署操作
2. 每个worker是独立的进程，如果有一个worker出现问题，其他worker是独立的，继续进行争抢，实现请求过程，不会造成服务中断。

`设置多少Worker合适？`

Nginx同Redis类似都采用io多路复用机制，每个Worker都是一个独立的进程，
但每个进程里只有一个主线程，通过异步非阻塞方式来处理请求，即使是成千上万个请求也不在话下，
每个Worker的线程可以把一个Cpu的性能发挥到极致.所以worker数和服务器的Cpu数相等是最为适宜。
设少了会浪费Cpu，设多了会造成Cpu平凡切换上下文带来损耗。

`发送请求，占用了worker的几个连接数(worker connection)？`

两个或者四个（看应用场景）

`Nginx有一个master，有四个worker，每个worker支持最大的连接数是1024，支持的并发数是多少个？`

普通的静态访问最大并发数：worker_connection*worker_process/2 
作为反向代理来说，最大支持并发数量应该是：worker_connection*worker_process/4

## Nginx安装、常用命令
### 最简安装
```
docker run --name some-nginx -v /some/content:/usr/share/nginx/html:ro -d nginx
```
### 普通安装
### 高可用
### 常用命令
* 查看nginx的版本号 nginx -v
* 启动nginx nginx
* 关闭nginx nginx -s stop
* 重新加载nginx ./nginx -s reload

## Nginx配置
### 配置文件介绍
* 配置文件位置
```
/usr/local/nginx/conf/nginx.conf
```
* 配置文件组成
  1. `全局块`
  从配置文件开始到events块之间的内容，主要会设置一些影响nginx服务器整体运行的配置指令，主要包括配置运行nginx服务器的用户（组）、
     允许生成的work process数，进程PID存放路径、日志存放路径和类型以及配置文件的引入等。
     例如worker processes 1；worker_processes值越大，可以支持的并发处理量也越多。
  
  2. `events块`
  events块涉及的指令主要影响nginx服务器与用户的网络连接，常用的设置包括是否开启对多work process下的网络连接进行序列化，
  是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求， 每个word process可以同时支持的最大连接数等。
  events { worker_connections 1024; } 上述例子就表示每个work process支持的最大连接数为1024。 
  这部分的配置对nginx的性能影响较大，在实际中应该灵活配置。
  
  3. `http块`
  这块是nginx服务器中配置最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。需要注意的是，
  http块也可以包括http全局块、server块。http全局块，http全局块配置的指令包括文件引入、MIMIE-TYPE定义、
  连接超时时间、单链接请求数上限等。
  
  4. `server块`
  server块，这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，
  该技术的产生是为了节省互联网服务器的硬件成本。每个http块可以包括多个server块，而每个server块就相当于一个虚拟主机。
  而每个server块也分为全局server块，以及可以同时包含多个location块。

  5. `location块`
  如果url包含正则表达式，则必须要有~或者~*标识。location [ = | ~ | ~* | ^~] url { }
  * =：用于不含正则表达式的url前，要求请求字符串与url严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。
  * ~：用于表示url包含正则表达式，并且区分大小写。
  * ~*：用于表示url包含正则表达式，并且不区分大小写。
  * ^~:用于不包含正则表达式的url前，要求nginx服务器找到标识url和请求字符串匹配度最高的location后，立即使用此location处理请求，而不再用location块中的正则url和请求字符串做匹配。

### 正向代理
![](/img/forward_proxy.png)
介绍：在客户端（浏览器）配置代理服务器，通过代理服务器进行互联网访问。

实现效果：打开浏览器，设置代理服务器，可以访问无法访问的其他域地址。

具体配置：
```
server {
    resolver 114.114.114.114; #指定DNS服务器IP地址 
    listen 80; 
    location / { 
        proxy_pass http://$host$request_uri; #设定代理服务器的协议和地址 
        proxy_set_header HOST $host; 
        proxy_buffers 256 4k; 
        proxy_max_temp_file_size 0k; 
        proxy_connect_timeout 30; 
        proxy_send_timeout 60; 
        proxy_read_timeout 60; 
        proxy_next_upstream error timeout invalid_header http_502; 
    }
} 
server { 
    resolver 114.114.114.114; #指定DNS服务器IP地址 
    listen 443; 
    location / { 
        proxy_pass https://$host$request_uri; #设定代理服务器的协议和地址 
        proxy_buffers 256 4k; 
        proxy_max_temp_file_size 0k; 
        proxy_connect_timeout 30; 
        proxy_send_timeout 60; 
        proxy_read_timeout 60; 
        proxy_next_upstream error timeout invalid_header http_502; 
    } 
}
```

### 反向代理
![](/img/reverse_proxy.png)
介绍：反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，
由反向代理服务器去选择目标服务器获取数据后，再返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器的地址，
隐藏了真实服务器IP地址。

实现效果：打开浏览器，在浏览器地址栏输入网址www.bookhub.com.cn，跳转linux系统中部署的服务主页。

具体配置：
```
server { 
    listen 80; 
    server_name www.bookhub.com.cn; 
    location / { 
        proxy_pass http://127.0.0.1:8080; 
    } 
}
```

### 负载均衡
![](/img/load_balancing.png)
介绍：单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，
将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡。

随着互联网信息爆炸性增长，负载均衡已经不再是一个很陌生的话题，顾名思义，负载均衡即是将负载分摊到不同的服务单元，既保证服务的可用性，
又保证响应的足够快，给用户很好的体验。在linux下有nginx、LVS、Haproxy等等服务可以提供负载均衡服务，
而且Nginx提供了几种分配方式：
1. `轮询`每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。
2. `权重`weight代表权重，默认为一，权重越高被分配的客户端越多。 指定轮询几率，weight和访问率成正比，用于后端服务器性能不均的情况。
3. `ip_hash`每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。
4. `Fair`按后端服务器的响应时间来分配请求，响应时间短的优先分配。

实现效果：浏览器输入网址，请求按某种规则分配到后端服务上。

具体配置：
```
http{
    ......
    upstream backend {
      ip_hash;
      server 127.0.0.1:8080 weight=1;
      server 192.168.0.100:8080 weight=1;
    }
    ......
    server{
      ......
      location / {
          ......
          proxy_pass http://backend;
          proxy_connect_timeout 10;
      }
    }
}
```

### 动静分离
![](/img/dynamic_static_separation.png)
介绍：为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。
Nginx动静分离简单来说就是把静态和动态请求分开，不能理解成只是单纯的把动态页面和静态页面物理分离。
动静分离从目前实现角度来讲大致分两种，一种是纯粹把静态文件独立成单独域名，放在独立的服务器上，也是目前主流推崇的方案。
另外一种方案是动态文件跟静态文件混合在一起发布，通过Nginx分开。通过location指定不同的后缀名实现不同的请求转发，
通过expires参数设置，可以设置浏览器缓存的过期时间，减少客户端对服务器之间的请求和流量。
具体expires定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，
所以不会产生额外的流量，此种方法非常适合不经常变动的资源（如果经常更新的文件，不建议使用expirse来缓存），
设置3d，表示在这三天之内去访问这个url，发送一个请求，比对该文件最后更新时间没有变化，则不会从服务器抓取，
返回状态码304，如果有修改，则直接从服务器重新下载，返回状态码200。

实现效果：访问静态文件直接请求文件服务器，其他请求才会访问后端服务。

配置：
```
location /static {
    alias /Django/static;  # 设置静态文件的路径
}

location /upload {
    alias /Django/upload;  # 设置上传文件的路径
}
```

### SSL证书配置

### 资源压缩
介绍：Nginx资源压缩建立在动静分离的基础之上，如果一个静态资源的size越小，那么自然传输速度会更快，同时也会更节省带宽。
在项目部署时，可以通过Nginx对于静态资源实现压缩传输，一方面可以节省带宽资源，第二方面也可以加快响应速度并提升系统吞吐。
Nginx提供了3个支持资源压缩的模块ngx_http_gzip_module、ngx_http_gzip_static_module和ngx_http_gunzip_module，
其中ngx_http_gzip_module属于内置模块，代表可以直接使用该模块下的一些压缩命令，部分配置指令如下。
![](/img/nginx_gzip.png)

实现效果：传输文件被压缩，降低带宽占用。

配置：

### 缓冲区

### 缓存机制

### IP黑白名单

### 跨域配置

### 防盗链

### 大文件传输

## Nginx性能优化
### 配置长连接

### 配置零拷贝

### 无延迟或多包并发机制

### 调整Worker工作进程

### 开启CPU亲和机制

### 开启epoll模型及调整并发连接数