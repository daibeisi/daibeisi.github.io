---
layout:     post
title:      Python学习笔记
subtitle:   ......
date:       2018-6-23
author:     呆贝斯
header-img: img/python.png
catalog: true
tags:
    - Python
---
# Python 入门

## 编译型语言和解释型语言
编程都是用的高级语言，计算机不能直接理解高级语言，只能理解和运行机器语言，
所以必须要把高级语言转成机器语言，计算机才能运行高级语言别写的程序。
+ 编译型
![](/img/compile.png)
+ 解释型
![](/img/explain.png)
Python程序文件的扩展名通常为.py。执行Python程序时，首先Python解释器将.py文件中的源代码翻译成中间码.pyc文件，
再由Python虚拟机逐条将中间码翻译成机器指令执行。

## Python简介
Python（发音：/ˈpaɪθən/ ）是一种强大的编程语言，它简单易学，提供众多高级的数据结构，让我们可以面向对象进行编程。
Python 的语法优雅，由于是一个解释性语言，更贴近人类自然语言，符合人类惯常的认识逻辑。

## Python 的应用领域
Python 跨平台，它能够运行在所有的常见操作系统上。它在近期热门的大数据、科学研究、机器学习、人工智能等领域大显身手，
同时 Python 几乎在所有领域都有所应用，对于学习它来说十分划算。

## Python 的优缺点
+ 优点
  1. 代码量少：这是简洁、优雅、明确、众多三方库带来的效果，可以让我们在处理同一个需求时相较其他语言撰写更少的代码量，大大节省了我们的时间，提高了效率；
  2. 应用范围广：可以做数据处理、机器学习、AI、图形视频处理、游戏、软件、网站等等，一种技能解决更多的问题，不用为了解决某个需要去专门学习对应的语言。
+ 缺点
  1. 慢：只有在大规模工业化的使用时才突显，对于我们日常使用差别很小，同时也可以用提高硬件配置的方案对冲，因为硬件的成本对于我们的时间来说时间更为宝贵。同时，目前也有一些解决方案来处理这方面的问题；
  2. 开源：这个其实是一个优点，开源可以带去分享，让我们有更多的学习资源，网络上 Python 的资料往往是比其他语言更多的。至于之前卖给别人软件担心别人看到源代码的顾虑，现在已经越来越没有必要，大多软件服务都是提供 Saas 服务、云服务的形式，将软件部署在自己的服务器上，给客户开一个账号就可以了。

# Python 安装和配置

## 普通安装
[Python安装](http://c.biancheng.net/view/4161.html)

## 使用 Anaconda
[Anaconda创建激活退出删除虚拟环境](https://blog.bookhub.com.cn/2022/04/20/Anaconda%E5%88%9B%E5%BB%BA%E6%BF%80%E6%B4%BB%E9%80%80%E5%87%BA%E5%88%A0%E9%99%A4%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/)

# Python 的数据类型和变量

## 类型体系
* 类型 type
* 空类型 NoneType
* 数字 numeric
  * 整型 int
    * 布尔 bool
  * 浮点 float
  * 复数 complex
* 容器 collections
  * 序列 sequence
    * 可变序列 abc.MutableSequence
      * 列表 list
      * 字节数组 bytearray
    * 不可变序列 ImmutableSequence
      * 元组 tuple
      * 字符串 string
      * 等差数列 range
      * 字节串 bytes
      * 内存视图 memoryview
  * 集合 set
    * 可变集合 set
    * 不可变集合 frozenset
  * 映射 mapping
    * 字典 dict
* 上下文管理器 context manager
* 类型注解的类型 type annotation
* 其他内置类型
  * 迭代器 iterator
    * 生成器 generator
  * 模块 module
  * 类与类实例 class/instances
  * 函数 function
  * 方法 method
  * 代码 code
  * 省略符 Ellipsis
  * 未实现 NotImplemented
  * 栈帧 frame
* 扩展类型 (内置库)
  * 高效数组 array.array
  * 枚举 enum.Enum
  * 有理数 fractions.Fraction
  * 指定精度浮点数 decimal.Decimal
  * 时间 datetime.datetime
  * 命名元组 collections.namedtuple
  * 双向队列 collections.deque
  * 有序字典 collections.OrderedDict
  * 映射链 collections.ChainMap
  * 计数器 collections.Counter
  * 默认字典 collections.defaultdict

## 常用数据类型
1. bool
2. int 
3. float 
4. str 
5. list 
6. tuple 
7. dict 
8. set 
9. date
10. datetime

## 鸭子类型
鸭子类型（duck typing）在程序设计中是动态类型的一种风格。
在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，
而是由"当前方法和属性的集合"决定。
```
# 这是一个鸭子（Duck）类
class Duck:
    def eat(self):
        print("A duck is eating...")

    def walk(self):
        print("A duck is walking...")

# 这是一个狗（Dog）类
class Dog:
    def eat(self):
        print("A dog is eating...")

    def walk(self):
        print("A dog is walking...")

def animal(obj):
    obj.eat()
    obj.walk()

if __name__ == '__main__':
    animal(Duck())
    animal(Dog())
```

## 可变与不可变
标准的数据类型中，有些是可变的，有些是不可以变的，不可变就意味差你不能对它进行操作，只能读取。
不可变数据：Number（数字）、String（字符串）、Tuple（元组）；
可变数据：List（列表）、Dictionary（字典）、Set（集合）。

## 数据类型判断
Python 内置的 type() 函数可以查看数据的类型，如：
```python
type(123) # 返回 int
# int

a = "Hello"
type(a) # 返回 str
# str
```
也可以用 isinstance 来判断它是不是一个指定的类型：
```python
isinstance(123, int) # 123 是不是一个数字整型
# True
isinstance('123', int)
# False
isinstance(True, bool)
# True
```

## 自定义数据类型
在 Python 中，可以使用类（class）来定义自己的数据类型。类是一种用户自定义的数据类型，它可以封装数据和方法，
从而实现面向对象编程（Object Oriented Programming，OOP）的概念。

## 变量

# Python 程序的流程

## while 循环
```
#0. [ While 之前的代码 ]

#1. [ While  {表达式} ]
    #1.1 { While 循环代码}

#2.[ While 之后的代码 ]
```
逻辑解释：
1. 开始执行
2. 先执行 #0 行
3. 执行 #1 ，如果 {表达式} 为 True，执行 #1.1
4. 执行完 #1.1 后再执行 #1，如此往复
5. 如果执行到 #1 {表达式} 为 False, 执行 #2
6. 结束执行

## if else 条件语句
## for 循环
## break 和 continue
## rang() 函数
## with as 上下文管理器
## match case 结构化模式匹配
## assert 断言

# Python 函数
## 定义及参数详解
函数是Python里面组织代码的最小单元。
## 返回值
## 闭包（closure）
什么是闭包？在一个内部函数中，对外部作用域的变量进行引用，(并且一般外部函数的返回值为内部函数)，即使外部函数已经执行完毕，
内部函数仍然可以使用这些变量和参数，那么内部函数就被认为是闭包。构成条件：
1. 函数嵌套
2. 外部函数返回内部函数名
3. 内部函数使用外部函数的变量

````python
def example1(x):
    # 嵌套函数inner()，则是一个闭包函数
    def inner(y):
        return x + y   # 引用外部函数的变量

    return inner

print(example1(6)(5))

def example2(a, b=1):
    c = 100

    def useC():
        print(f'调用外部函数的变量，并打印：{c}')   # 100
        print(a + b)    # 17

    useC()

example2(6, 11)   # 实参值会覆盖形参的值
````

闭包可以保存函数的状态信息，使函数的局部变量信息依然可以保存下来，将外层函数的变量持久地保存在内存中。

以一个类似棋盘游戏的例子来说明。假设棋盘大小为50*50，左上角为坐标系原点(0,0)，我需要一个函数，接收2个参数，分别为方向(direction)，
步长(step)，该函数控制棋子的运动。 这里需要说明的是，每次运动的起点都是上次运动结束的终点。

```python
def create(pos=origin):
    def go(direction,step):
        new_x = pos[0] + direction[0]*step
        new_y = pos[1] + direction[1]*step
        pos[0] = new_x
        pos[1] = new_y
        return pos
    
    return go


player = create()
print(player([1,0],10))
print(player([0,1],20))
print(player([-1,0],10))
```

## lambda

# Python 面向对象编程

## 面向对象编程概念
+ `面型对象`：是一种符合人类思维习惯的编程思想。客观世界中存在多种形态的事务，这些事物之间存在各种各样的联系。
在程序中使用对象来模拟现实中的事务，使用对象之间的关系来描述事物之间的联系，这种思想就是面对对象。
+ `对象`：一切事物皆为对象，将事物的属性和方法封装在一起，形成一个实体，这个实体就是对象。
+ `类`：具有相同属性和功能的对象的抽象。
+ `实例`：是一个真实的对象。比如我们都是”人“，所以你和我都是“人”类的实例。
+ `实例化`：创建对象的过程。

## 面向对象 VS 面向过程

# Python 的错误、调试和测试

## 错误

### 语法错误
语法错误就是解析代码时出现的错误。当代码不符合Python语法规则时，
Python解释器在解析时就会报SyntaxError语法错误，还会指出最早探测到错误的语句。
语法错误是解释器无法容忍的，必须全部纠正才能运行。

### 运行错误

### 异常处理 try except
1. 了解Python异常处理机制
2. try except else
3. try except finally
4. raise
    调试程序时看某些库的源代码，发现有如下代码读不懂，不理解后面这个from干什么用的。

    ```
    try:
    ...
    except KeyError:
        raise **Error('') from None
    
    try:
        ...
    except Exception as exc:
        raise **Error('') from exc
    ```
   
    先看普通写法，控制台会输出什么，结果如下。控制台输出了2个异常发生的位置和原因，同时在2个提示中间输出一句话“在处理上述异常时，又发生了另一个异常”。
    
    ```
    try:
        print(1/0)
    except Exception as exc:
        raise RuntimeError('程序执行过程中发生错误')
    
    Traceback (most recent call last):
      File "D:/*/tests.py", line 5, in <module>
        print(1/0)
    ZeroDivisionError: division by zero
    
    During handling of the above exception, another exception occurred:
    
    Traceback (most recent call last):
      File "D:/*/tests.py", line 7, in <module>
        raise RuntimeError('程序执行过程中发生错误')
    RuntimeError: 程序执行过程中发生错误
    ```
    
    再看raise **Error('') from exc写法，控制台输出了什么，结果如下。控制台输出了2个异常发生的位置和原因，同时在2个提示中间输出一句话“上述异常是下列异常的直接原因”。
    
    ```
    try:
        print(1/0)
    except Exception as exc:
        raise RuntimeError('程序执行过程中发生错误') from exc
    
    Traceback (most recent call last):
      File "D:/WorkSpace/backend/user/tests.py", line 5, in <module>
        print(1/0)
    ZeroDivisionError: division by zero
    
    The above exception was the direct cause of the following exception:
    
    Traceback (most recent call last):
      File "D:/WorkSpace/backend/user/tests.py", line 7, in <module>
        raise RuntimeError('程序执行过程中发生错误') from exc
    RuntimeError: 程序执行过程中发生错误
    ```
    
    最后看raise **Error('') from None写法，控制台输出了什么，结果如下。控制台只输出了我们写的抛出异常。
    
    ```
    try:
        print(1/0)
    except Exception as exc:
        raise RuntimeError('程序执行过程中发生错误') from None
    
    Traceback (most recent call last):
      File "D:/WorkSpace/backend/user/tests.py", line 7, in <module>
        raise RuntimeError('程序执行过程中发生错误') from None
    RuntimeError: 程序执行过程中发生错误
    ```
    
    总结：from 会为异常对象设置 __cause__ 属性表明异常的是由谁直接引起的。处理异常时发生了新的异常，
    在不使用 from 时更倾向于新异常与正在处理的异常没有关系。而 from 则是能指出新异常是因旧异常直接引起的。
    这样的异常之间的关联有助于后续对异常的分析和排查。from 语法会有个限制，就是第二个表达式必须是另一个异常类或实例。
    如果在异常处理程序或 finally 块中引发异常，默认情况下，
    异常机制会隐式工作会将先前的异常附加为新异常的 __context__属性。当然，
    也可以通过with_traceback()方法为异常设置上下文__context__属性，这也能在traceback更好的显示异常信息。
    from 还有个特别的用法：raise ... from None ，它通过设置 __suppress_context__ 属性指定来明确禁止异常关联。
    在异常处理程序或finally块中引发异常，可以通过from来指定异常因谁引起的。这些手段都是为了得到更友好的异常回溯信息，
    打印清晰的异常上下文。若要忽略上下文，则可以通过 raise ... from None 来禁止自动显示异常上下文。

5. sys.exec_info()获取异常信息

6. traceback模块获取异常信息

# Python 文件处理和IO编程

# Python 的并发编程

## 进程

## 线程

## 协程

# Python的脚本编程与系统管理

# Python 的正则表达式

# 模块与包

## Python 常用内置模块

## Python 常用第三方模块

# Python 图形界面

# Python 网络与 Web 编程

# Python 电子邮件

# Python 访问数据库

# Python 的 Web 开发

# 使用 MicroPython

# Python 高级特性

## 切片

## 迭代

## 列表生成式

## 生成器（Generator）
生成器是一个特殊的迭代器，并且它也是一个可迭代对象。有 2 种方式可以创建一个生成器：
1. 生成器表达式
2. 生成器函数

## 迭代器（Iterator）
迭代器是带状态的对象，它会记录当前迭代所在的位置，以方便下次迭代的时候获取正确的元素。一个对象要想使用 for 的方式迭代出容器内的所有数据，
这就需要这个类实现「迭代器协议」。也就是说，一个类如果实现了迭代器协议，就可以称之为迭代器。

在 Python 中，实现迭代器协议就是实现以下 2 个方法：
1. __iter__：这个方法返回对象本身，即 self
2. __next__：这个方法每次返回迭代的值，在没有可迭代元素时，抛出 StopIteration 异常

```
class A:
    """A 实现了迭代器协议 它的实例就是一个迭代器"""
    def __init__(self, n):
        self.idx = 0
        self.n = n

    def __iter__(self):
        return self

    def __next__(self):
        if self.idx < self.n:
            val = self.idx
            self.idx += 1
            return val
        else:
            raise StopIteration()
```

## 装饰器（Decorator）
装饰器是Python中最吸引人的特性，装饰器本质上还是一个函数，它可以让已有的函数不做任何改动的情况下增加功能。

## 元编程

## C语言扩展
开发者有如下方法在Python代码中调用C编写的函数，每种方式都有各自的利弊。要明确为什么在Python中调用C，常见原因如下：
提升代码运行速度；
C语言中有很多传统类库，这些是想用的，但不想用Python重写；
想对内存到文件接口这种底层资源进行访问；
* ctypes
Python中ctypes模块可能是Python调用C最简单一种方法，ctypes模块提供了和C语言兼容的数据类型和函数来加载dll文件，因此，
在调用时不需要对源文件做任何的修改。
1. 编写C语言代码并保存。
    ```
    #include<stdio.h>

    int add_int(int num1, int num2){
        return num1+num2;
    };
    ```

2. 将C语言代码文件编译为.so文件。`gcc -shared -Wl,-soname,adder -o adder.so -fPIC add.c`

3. 在Python代码中调用.so文件。
    ```
    from ctypes import *

    adder = CDLL('./adder.so')
    res_int = adder.add_int(4,5)
    print(res_int)
    ```

* SWIG
* Python/C API

# 数据结构与算法

# 数据编码与处理

## base64

# 新版本特性

## 3.10 引入了 match 语句
```
grade = 3
match grade:
    case 1:
        print('一年级')
    case 2:
        print('二年级')
    case 3:
        print('三年级')
    case _:
        print('未知年级')
```

## 3.9 增加了合并和更新运算符 (|=)
```
dictA = {'A': 'a', 'B': 'b'}
dictB = {1: 1, 2: 2}
dictC = {3: 3, 4: 4}

dictA |= dictB
merge_dict = dictB | dictC
```

## 3.8 增加了 F-strings 表达式
```
name = "foo"
f"Hello, my name is {name}"
```

## 3.8 新增海象运算符
```
lis = [1, 2, 3]
length = len(lis)
if length > 3:
    print("lis列表拥有{}个元素，大于3。".format(length))

# 使用海象运算符后
if length := len(lis) > 3:
    print("lis列表拥有{}个元素，大于3。".format(length))
```

## 3.5 新增类型注解
```
age: int = 8
name: str = "zhangsan"

from typing import List, Set, Dict, Tuple
lis: List[str] = ["zhangsan","lisi"]
dic: Dict[str, int] = {"zhangsan": 18}
```

## 函数参数和返回值的类型声明
```
def add(a: int, b: int) -> int:
    return a + b
```