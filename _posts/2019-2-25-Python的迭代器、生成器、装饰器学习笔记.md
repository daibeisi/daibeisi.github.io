---
layout:     post
title:      Python的闭包、装饰器、迭代器和生成器学习笔记
subtitle:   ...
date:       2019-2-25
author:     呆贝斯
header-img: img/post-bg-desk.jpg
---
# 闭包（closure）
什么是闭包？在一个内部函数中，对外部作用域的变量进行引用，(并且一般外部函数的返回值为内部函数)，即使外部函数已经执行完毕，
内部函数仍然可以使用这些变量和参数，那么内部函数就被认为是闭包。构成条件：
1. 函数嵌套
2. 外部函数返回内部函数名
3. 内部函数使用外部函数的变量
````
def example1(x):
    # 嵌套函数inner()，则是一个闭包函数
    def inner(y):
        return x + y   # 引用外部函数的变量

    return inner


print(example1(6)(5))


def example2(a, b=1):
    c = 100

    def useC():
        print(f'调用外部函数的变量，并打印：{c}')   # 100
        print(a + b)    # 17

    useC()


example2(6, 11)   # 实参值会覆盖形参的值
````
闭包可以保存函数的状态信息，使函数的局部变量信息依然可以保存下来，将外层函数的变量持久地保存在内存中。

以一个类似棋盘游戏的例子来说明。假设棋盘大小为50*50，左上角为坐标系原点(0,0)，我需要一个函数，接收2个参数，分别为方向(direction)，
步长(step)，该函数控制棋子的运动。 这里需要说明的是，每次运动的起点都是上次运动结束的终点。
```
def create(pos=origin):
    def go(direction,step):
        new_x = pos[0] + direction[0]*step
        new_y = pos[1] + direction[1]*step
        pos[0] = new_x
        pos[1] = new_y
        return pos
    
    return go


player = create()
print(player([1,0],10))
print(player([0,1],20))
print(player([-1,0],10))
```

# 迭代器（Iterator）
迭代器是带状态的对象，它会记录当前迭代所在的位置，以方便下次迭代的时候获取正确的元素。一个对象要想使用 for 的方式迭代出容器内的所有数据，
这就需要这个类实现「迭代器协议」。也就是说，一个类如果实现了迭代器协议，就可以称之为迭代器。

在 Python 中，实现迭代器协议就是实现以下 2 个方法：
1. __iter__：这个方法返回对象本身，即 self
2. __next__：这个方法每次返回迭代的值，在没有可迭代元素时，抛出 StopIteration 异常
```
class A:
    """A 实现了迭代器协议 它的实例就是一个迭代器"""
    def __init__(self, n):
        self.idx = 0
        self.n = n

    def __iter__(self):
        return self

    def __next__(self):
        if self.idx < self.n:
            val = self.idx
            self.idx += 1
            return val
        else:
            raise StopIteration()
```

# 生成器（Generator）
生成器是一个特殊的迭代器，并且它也是一个可迭代对象。有 2 种方式可以创建一个生成器：
1. 生成器表达式
2. 生成器函数

# 装饰器（Decorator）
装饰器是Python中最吸引人的特性，装饰器本质上还是一个函数，它可以让已有的函数不做任何改动的情况下增加功能。