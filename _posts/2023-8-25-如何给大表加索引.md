---
layout:     post
title:      如何给大表加索引
date:       2023-8-25
author:     呆贝斯
header-img: img/post-bg-rwd.jpg
catalog: true
tags:
    - 数据库
---
# 场景
业务表随数据增加已达亿级，需要加索引进行优化查询。

# 思考


# 实现步骤
## 影子拷贝
1. 创建一张与原表（tb）结构相同的新表（tb_bak）
    ```
    create table tb_bak like tb;
    ```
2. 在新表上创建索引
    ```
    alter table tb_new add index idx_col_name (col_name);
    ```
3. 重命名原表为其他表名（tb => tb_tmp），新表重命名为原表名（tb_bak => tb），此时新表（tb）承担业务
    ```
    rename table tb to tb_tmp, tb_new to tb;
    ```
4. 为原表（tb_tmp）新增索引
    ```
    rename table tb to tb_tmp, tb_new to tb;
    ```
5. 交换表，新表改回最初的名称（tb => tb_new），原表改回最初的名称（tb_tmp => tb），原表（tb）重新承担业务
    ```
    rename table tb to tb_new, tb_tmp => tb;
    ```
6. 把新表数据导入原表（即把新表承担业务期间产生的数据和到原表中）
    ```
    insert into tb (col_name1, col_name2) select col_name1, col_name2 from tb_new;
    ```

步骤3之后，新表改为原表名后（tb）开始承担业务，步骤3到结束之前这段时间的新产生的数据都是存在新表中的，
但是如果有业务对老数据进行修改或删除操作，那将无法实现，所以步骤3到结束这段时间可能会产生数据（更新和删除）丢失。

## pt-online-schema-change
PERCONA提供若干维护MySQL的小工具，其中 pt-online-schema-change（简称pt-osc）便可用来相对安全地对大表进行DDL操作。
pt-online-schema-change 方案利用三个触发器（DELETE\UPDATE\INSERT触发器）解决了“影子策略”存在的问题，
让新老表数据同步时发生的数据变动也能得到同步。

1. 创建一张与原表结构相同的新表
2. 对新表进行DDL操作（如加索引）
3. 在原表上创建3个触发器（DELETE\UPDATE\INSERT），用来原表复制到新表时（步骤4）的数据改动时的同步
4. 将原表数据以数据块（chunk）的形式复制到新表
5. 表交换，原表重命名为old表，新表重命名原表名
6. 删除旧表，删除触发器

## 在线无锁加索引
MySQL5.6.7 之前由于DDL实现机制的局限性，常用“影子策略”和 pt-online-schema-change 方案进行DDL操作，保证相对安全性。
在 MySQL5.6.7 版本中新推出了 Online DDL 特性，支持“无锁”DDL。5.7版本已趋于成熟，所以在5.7之后可以直接利用 ONLINE DDL特性。
对于 ONLINE DDL 下的 inplace 方式，分为了 rebuild table 和 no-rebuild table。

Online DDL大致可分为三个阶段：初始化、执行和提交。

Initialization阶段
此阶段会使用MDL读锁，禁止其他并发线程修改表结构
服务器将考虑存储引擎能力、语句中指定的操作以及用户指定的ALGORITHM 和 LOCK选项，确定操作期间允许的并发数

Execution阶段
此阶段分为两个步骤 Prepared and Executed
此阶段是否需要MDL写锁取决于Initialization阶段评估的因素，如果需要MDL写锁的话，仅在Prepared过程会短暂的使用MDL写锁
其中最耗时的是Excuted过程

Commit Table Definition阶段
此阶段会将MDL读锁升级到MDL写锁，此阶段一般较快，因此独占锁的时间也较短
用新的表定义替换旧的表定义(如果rebuild table)

ONLINE DDL 过程
1. 获取对应要操作表的 MDL（metadata lock）写锁
2. MDL写锁 降级成 MDL读锁
3. 真正做DDL操作
4. MDL读锁 升级成 MDL写锁
5. 释放MDL锁



